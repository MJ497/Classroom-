<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ZeroTwo Classroom</title>
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="main.css">
  <style>
    /* small helper styles for modals, icons and full width behavior */
    .modal.centered{display:none;position:fixed;inset:0;align-items:center;justify-content:center;background:rgba(0,0,0,0.45);z-index:60}
    .modal .box{background:#fff;padding:18px;border-radius:10px;min-width:300px;max-width:640px}
    .msg-success{display:flex;gap:8px;align-items:center;color: #064e3b}
    .msg-error{display:flex;gap:8px;align-items:center;color:#7f1d1d}
    .btn.small{padding:6px 10px;font-size:13px}
    body.in-room .container{padding:0;margin:0;max-width:100%;}
    body.in-room header{display:none}
    .classroom{display:grid;grid-template-columns:280px 1fr 360px;gap:12px;padding:12px}
    @media (max-width:980px){ .classroom{grid-template-columns:1fr;}} 
    .controls{display:flex;gap:8px;align-items:center}
    .mute-btn{display:inline-flex;align-items:center;gap:6px}
    .full-toggle{margin-left:8px}
  </style>
</head>
<body>
  <header>
    <div class="logo-container">
      <img src="logo.png" alt="Logo" style="height:40px;width:40px;object-fit:cover">
      <h1>ZeroTwo Classroom</h1>
    </div>
    <div id="userInfo"></div>
    <button id="signBtn" class="btn small">Sign in</button>
  </header>

  <div class="container">
    <section class="hero" id="heroSection">
      <div class="lead">
        <h2>Teach. Share Screen. Chat. Record.</h2>
        <p class="small">Sign in, create a classroom and share the joining link. Only the creator can share screen and record the session (saved to Firebase Storage).</p>
      </div>
      <div style="display:flex;gap:8px; justify-content: center;">
        <button id="createBtn" class="btn">Create classroom</button>
        <button id="joinBtn" class="btn" style="background:#0ea5a4">Join classroom</button>
      </div>
    </section>

    <div id="roomArea" style="margin-top:18px"></div>
  </div>

  <!-- Join modal -->
  <div id="joinModal" class="modal centered">
    <div class="box">
      <h3>Join classroom</h3>
      <input id="joinInput" placeholder="Paste join link or room id" style="width:100%;padding:8px;margin:8px 0;border-radius:6px;border:1px solid #ddd" />
      <div style="display:flex;gap:8px;justify-content:flex-end">
        <button id="closeJoin" class="btn small" style="background:#ef4444">Cancel</button>
        <button id="doJoin" class="btn small">Join</button>
      </div>
    </div>
  </div>

  <!-- Generic modal for errors/success -->
  <div id="statusModal" class="modal centered">
    <div class="box" role="dialog" aria-modal="true">
      <div id="statusContent"></div>
      <div style="display:flex;justify-content:flex-end;margin-top:10px">
        <button id="closeStatus" class="btn small">Close</button>
      </div>
    </div>
  </div>

  <script type="module">
    // ---- Firebase config (keep as provided) ----
    const firebaseConfig = {
      apiKey: "AIzaSyBo8cWA_2U6aVps16fug4M_E0-wRRhJfio",
      authDomain: "classs-89e58.firebaseapp.com",
      databaseURL: "https://classs-89e58-default-rtdb.firebaseio.com",
      projectId: "classs-89e58",
      storageBucket: "classs-89e58.firebasestorage.app",
      messagingSenderId: "93885082867",
      appId: "1:93885082867:web:36525ce788ced914f01b86"
    };

    // Firebase modular SDK
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js';
    import { getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js';
    import { getFirestore, doc, setDoc, getDoc, onSnapshot, collection, addDoc, serverTimestamp, query, orderBy, deleteDoc } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js';
    import { getStorage, ref as storageRef, uploadBytes, getDownloadURL } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-storage.js';

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const storage = getStorage(app);

    // App state
    let currentUser = null;
    let currentRoomId = null;
    let localScreenStream = null;
    let localMicStream = null;
    let mediaRecorder = null;
    let recordedBlobs = [];
    const pcMap = {}; // peer connections keyed by ids (best-effort)

    // UI refs
    const signBtn = document.getElementById('signBtn');
    const userInfo = document.getElementById('userInfo');
    const createBtn = document.getElementById('createBtn');
    const joinBtn = document.getElementById('joinBtn');
    const roomArea = document.getElementById('roomArea');
    const joinModal = document.getElementById('joinModal');
    const joinInput = document.getElementById('joinInput');
    const closeJoin = document.getElementById('closeJoin');
    const doJoin = document.getElementById('doJoin');
    const statusModal = document.getElementById('statusModal');
    const statusContent = document.getElementById('statusContent');
    const closeStatus = document.getElementById('closeStatus');
    const heroSection = document.getElementById('heroSection');

    closeStatus.onclick = () => { statusModal.style.display = 'none'; };

    function showStatus(type, title, message){
      let html = '';
      if(type==='success') html = `<div class="msg-success"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M20 6L9 17L4 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg><div><strong>${title}</strong><div class="small">${message}</div></div></div>`;
      else html = `<div class="msg-error"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94A2 2 0 0 0 23 18L14.71 3.86a2 2 0 0 0-3.42 0z" stroke="currentColor" stroke-width="0" fill="currentColor"/></svg><div><strong>${title}</strong><div class="small">${message}</div></div></div>`;
      statusContent.innerHTML = html;
      statusModal.style.display = 'flex';
    }

    // Helper to convert RTC objects to plain JSON for Firestore
    function plain(obj){
      try{
        if(!obj) return null;
        if(typeof obj.toJSON === 'function') return obj.toJSON();
        // fallback: stringify then parse (strips prototypes)
        return JSON.parse(JSON.stringify(obj));
      }catch(e){
        console.warn('plain() conversion failed', e);
        try { return JSON.parse(JSON.stringify(obj)); } catch(e2){ return obj; }
      }
    }

    // Wrap Firestore-stored plain objects back into RTC types (safe)
    function asSessionDescription(obj){
      try{
        if(!obj) return null;
        return (typeof RTCSessionDescription !== 'undefined') ? new RTCSessionDescription(obj) : obj;
      }catch(e){
        console.warn('asSessionDescription error', e);
        return obj;
      }
    }
    function asIceCandidate(obj){
      try{
        if(!obj) return null;
        return (typeof RTCIceCandidate !== 'undefined') ? new RTCIceCandidate(obj) : obj;
      }catch(e){
        console.warn('asIceCandidate error', e);
        return obj;
      }
    }

    // Auth
    signBtn.onclick = async () => {
      if (!currentUser) {
        try{
          signBtn.disabled = true; signBtn.innerHTML = 'Signing in...';
          const provider = new GoogleAuthProvider();
          provider.addScope('profile'); provider.addScope('email');
          provider.setCustomParameters({ prompt: "select_account" });
          await signInWithPopup(auth, provider);
        }catch(error){
          console.error('Sign in error', error);
          if (error.code === 'auth/unauthorized-domain'){
            showStatus('error','Authentication Error','This domain is not authorized for Firebase authentication. Add it under Firebase Console > Authentication > Authorized domains.');
          } else {
            showStatus('error','Sign in failed',error.message || 'Unknown error');
          }
        }finally{ signBtn.disabled = false; signBtn.innerHTML = currentUser? 'Sign out':'Sign in'; }
      } else {
        try{ await signOut(auth); }catch(e){ console.warn(e);} 
      }
    };

    onAuthStateChanged(auth, user=>{
      currentUser = user;
      if(user){ userInfo.innerText = user.displayName || user.email; signBtn.innerText='Sign out'; }
      else{ userInfo.innerText=''; signBtn.innerText='Sign in'; }
    });

    // Create classroom
    createBtn.onclick = async () => {
      if (!currentUser) { showStatus('error','Sign in required','Please sign in to create a classroom. Guests may join without signing in.'); return; }
      try{
        createBtn.disabled=true; createBtn.innerText='Creating...';
        const id = generateId(8);
        const roomRef = doc(db,'rooms',id);
        await setDoc(roomRef,{ owner: currentUser.uid, ownerName: currentUser.displayName || currentUser.email, createdAt: serverTimestamp() });
        currentRoomId = id;
        // write participant entry
        await setDoc(doc(roomRef,'participants',currentUser.uid),{ name: currentUser.displayName || currentUser.email, joinedAt: serverTimestamp(), host: true });

        // Hide intro and make UI full width
        document.body.classList.add('in-room');
        heroSection.style.display = 'none';
        renderClassroom(true);
        attachRoomListeners(id);

        // Pre-acquire mic so host can speak if wanted
        try{ localMicStream = await navigator.mediaDevices.getUserMedia({audio:true}); } catch(e){ console.warn('Mic access denied or unavailable', e); }

        // show join link
        const link = window.location.origin + window.location.pathname + '?room=' + id;
        showStatus('success','Class created','Share this link with students:\n' + link);
      }catch(error){ console.error('Error creating',error); showStatus('error','Create failed',error.message || 'Unknown error'); }
      finally{ createBtn.disabled=false; createBtn.innerText='Create classroom'; }
    };

    // Join modal handlers
    joinBtn.onclick = () => { joinModal.style.display='flex'; }
    closeJoin.onclick = () => { joinModal.style.display='none'; }
    doJoin.onclick = async () => {
      const val = joinInput.value.trim(); if (!val) return showStatus('error','Input required','Enter a room id or full join link');
      try{
        doJoin.disabled=true; doJoin.innerText='Joining...';
        const id = parseRoomIdFromInput(val);
        const roomRef = doc(db,'rooms',id);
        const snap = await getDoc(roomRef);
        if(!snap.exists()) return showStatus('error','Not found','Room not found');
        currentRoomId = id;
        // attempt to acquire mic for participant
        try{ localMicStream = await navigator.mediaDevices.getUserMedia({audio:true}); }catch(e){ console.warn('mic denied',e); }
        // add participant doc
        await setDoc(doc(roomRef,'participants', currentUser ? currentUser.uid : generateId(6)),{
          name: currentUser ? (currentUser.displayName || currentUser.email) : 'Guest-'+generateId(4), joinedAt: serverTimestamp(), host:false
        });
        joinModal.style.display='none';
        document.body.classList.add('in-room');
        heroSection.style.display='none';
        renderClassroom(false);
        attachRoomListeners(id);
      }catch(error){ console.error('Join error',error); showStatus('error','Join failed',error.message || 'Unknown error'); }
      finally{ doJoin.disabled=false; doJoin.innerText='Join'; }
    };

    function renderClassroom(amHost){
      roomArea.innerHTML = `
        <div class="classroom" id="classroomRoot">
          <div class="panel">
            <h4>Participants</h4>
            <ul id="participantsList" class="participants"></ul>
          </div>
          <div class="panel" id="centerPanel" style="display:flex;flex-direction:column">
            <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
              <strong>Room:</strong><span id="roomId">${currentRoomId}</span>
              <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
                <div class="controls">
                  ${amHost ? '<button id="shareScreenBtn" class="btn small">Share screen</button>' : ''}
                  <button id="muteBtn" class="btn small mute-btn">Mute</button>
                  ${amHost ? '<button id="startRec" class="btn small">Start recording</button><button id="stopRec" class="btn small" style="display:none;background:#ef4444">Stop</button>' : ''}
                  <button id="fullscreenBtn" class="btn small full-toggle">Fullscreen</button>
                  <button id="leaveBtn" class="btn small" style="background:#ef4444">Leave</button>
                </div>
              </div>
            </div>
            <video id="mainVideo" autoplay playsinline style="width:100%;height:480px;background:#000"></video>
          </div>
          <div class="panel chat">
            <h4>Chat</h4>
            <div id="messages" class="messages" style="height:360px;overflow:auto"></div>
            <div class="composer">
              <input id="chatInput" placeholder="Write a message" />
              <button id="sendChat" class="btn small">Send</button>
            </div>
          </div>
        </div>
      `;

      // wire controls
      document.getElementById('leaveBtn').onclick = leaveRoom;
      document.getElementById('sendChat').onclick = sendChat;
      const muteBtn = document.getElementById('muteBtn');
      let muted = false;
      muteBtn.onclick = () => {
        muted = !muted;
        if(localMicStream) localMicStream.getAudioTracks().forEach(t=>t.enabled = !muted);
        muteBtn.innerText = muted ? 'Unmute' : 'Mute';
      };

      if(amHost){
        document.getElementById('shareScreenBtn').onclick = startShare;
        document.getElementById('startRec').onclick = startRecording;
        document.getElementById('stopRec').onclick = stopRecording;
      }

      document.getElementById('fullscreenBtn').onclick = () => {
        const center = document.getElementById('centerPanel');
        if (!center) return;
        if (!document.fullscreenElement) center.requestFullscreen?.();
        else document.exitFullscreen?.();
      };
    }

    // Room listeners (participants, chat, signaling)
    function attachRoomListeners(roomId){
      const participantsRef = collection(db,'rooms',roomId,'participants');
      const pQuery = query(participantsRef);
      onSnapshot(pQuery, snapshot=>{
        const list = document.getElementById('participantsList'); if(!list) return;
        list.innerHTML='';
        snapshot.forEach(docSnap=>{ const d=docSnap.data(); const li=document.createElement('li'); li.innerHTML=`<span class="status online"></span> ${(d.name||'Unknown') + (d.host? ' (host)' : '')}`; list.appendChild(li); });
      });

      // chat
      const messagesRef = collection(db,'rooms',roomId,'messages');
      const q = query(messagesRef, orderBy('ts'));
      onSnapshot(q, snap=>{
        const messages = document.getElementById('messages'); if(!messages) return; messages.innerHTML='';
        snap.forEach(s=>{ const m=s.data(); const div=document.createElement('div'); div.className='msg'; div.innerHTML=`<strong>${escapeHtml(m.name)}:</strong> ${escapeHtml(m.text)} <div class="small">${new Date(m.ts?.toMillis ? m.ts.toMillis() : Date.now()).toLocaleTimeString()}</div>`; messages.appendChild(div); });
        messages.scrollTop = messages.scrollHeight;
      });

      // signaling: offers -> we respond (create answers)
      const offersRef = collection(db,'rooms',roomId,'offers');
      onSnapshot(offersRef, async snap=>{
        snap.docChanges().forEach(async change=>{
          const id = change.doc.id; const data = change.doc.data();
          if(change.type==='added'){
            // ignore offers from self
            if(data.from === (currentUser?.uid||'guest')) return;
            console.log('Received offer',data.from);
            await handleOffer(roomId, id, data);
          }
        });
      });

      // answers -> apply to PCs
      const answersRef = collection(db,'rooms',roomId,'answers');
      onSnapshot(answersRef, snap => {
        snap.docChanges().forEach(async change=>{
          if(change.type !== 'added') return;
          const data = change.doc.data();
          try{
            if(data.to !== (currentUser?.uid||'guest')) return; // not for me
            const pc = pcMap[data.from];
            if(!pc){
              console.warn('No pc found for answer.from', data.from);
              return;
            }
            // convert plain answer to RTCSessionDescription and apply
            await pc.setRemoteDescription(asSessionDescription(data.answer));
            console.log('Applied remote answer from', data.from);
          }catch(err){
            console.warn('Error applying answer', err);
          }
        });
      });

      // ice candidates -> add to appropriate pc
      const iceRef = collection(db,'rooms',roomId,'ice');
      onSnapshot(iceRef, snap=>{
        snap.docChanges().forEach(async change=>{
          if(change.type !== 'added') return;
          const data = change.doc.data();
          try{
            // if candidate has a 'to' address and it's not for us, skip
            if(data.to && data.to !== (currentUser?.uid||'guest')) return;
            const pc = pcMap[data.from];
            if(!pc){
              // no pc keyed by sender; log and skip
              console.warn('No pc found for ice.from', data.from);
              return;
            }
            const cand = asIceCandidate(data.candidate);
            if(cand) await pc.addIceCandidate(cand);
          }catch(e){
            console.warn('addIceCandidate failed', e);
          }
        });
      });
    }

    // Handle incoming offer and create answer
    async function handleOffer(roomId, offerId, offerData){
      try{
        const fromId = offerData.from;
        // create pc for the remote (host) so we can play their stream
        const pc = createPeerConnection(fromId, roomId);
        // store pc keyed by the remote's id so future answers/ice can map
        pcMap[fromId] = pc;
        // set remote description (offer is plain object from Firestore)
        await pc.setRemoteDescription(asSessionDescription(offerData.offer));
        // if we have local mic, add it (so host can receive participant audio)
        if(localMicStream) localMicStream.getTracks().forEach(t=>pc.addTrack(t, localMicStream));
        // create answer
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        // save the plain answer object
        await addDoc(collection(db,'rooms',roomId,'answers'),{
          from: currentUser ? currentUser.uid : 'guest',
          to: fromId,
          answer: plain(pc.localDescription)
        });
      }catch(e){
        console.error('handleOffer error', e);
      }
    }

    // Start screen share (host)
    async function startShare(){
      try{
        const stream = await navigator.mediaDevices.getDisplayMedia({video:true,audio:false});
        localScreenStream = stream;
        const videoEl = document.getElementById('mainVideo'); videoEl.srcObject = stream;

        // If host also wants microphone mixed, we send mic tracks too when creating offer
        await createAndSendOffer(currentRoomId);

        stream.getTracks().forEach(t=>t.onended = ()=>{ if(videoEl) videoEl.srcObject = null; localScreenStream=null; });
      }catch(e){ console.error(e); showStatus('error','Screen share failed', e.message || e.toString()); }
    }

    // Create and send offer (host announces media). serialize RTC objects with plain()
    async function createAndSendOffer(roomId){
      const pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
      // add screen tracks + mic if available
      if(localScreenStream) localScreenStream.getTracks().forEach(t=>pc.addTrack(t, localScreenStream));
      if(localMicStream) localMicStream.getTracks().forEach(t=>pc.addTrack(t, localMicStream));

      // store pc keyed by current user so answers (addressed to us) can be found by their .from (guest) or host logic
      pcMap[currentUser ? currentUser.uid : 'host'] = pc;
      // also keep a timestamped copy to avoid collisions
      pcMap['local-offer-'+Date.now()] = pc;

      pc.onicecandidate = e=>{ if(!e.candidate) return; addDoc(collection(db,'rooms',roomId,'ice'),{ from: currentUser?currentUser.uid:'host', to:null, candidate: plain(e.candidate) }); };
      pc.ontrack = e=>{ const videoEl = document.getElementById('mainVideo'); if(videoEl) videoEl.srcObject = e.streams[0]; };

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      // store the offer as plain JSON
      await addDoc(collection(db,'rooms',roomId,'offers'),{
        from: currentUser?currentUser.uid:'host',
        offer: plain(pc.localDescription)
      });

      return offer;
    }

    // Create peer connection for incoming offers (guests will play host stream and possibly send mic)
    function createPeerConnection(peerId, roomId){
      const pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
      pc.onicecandidate = e=>{ if(!e.candidate) return; addDoc(collection(db,'rooms',roomId,'ice'),{ from: currentUser?currentUser.uid:'guest', to:peerId, candidate: plain(e.candidate) }); };
      pc.ontrack = e=>{ const videoEl = document.getElementById('mainVideo'); if(videoEl) videoEl.srcObject = e.streams[0]; };
      // If participant has mic, add it so host receives audio
      if(localMicStream) localMicStream.getTracks().forEach(t=>pc.addTrack(t, localMicStream));
      return pc;
    }

    // Chat send
    async function sendChat(){ const input = document.getElementById('chatInput'); const text = input.value.trim(); if(!text) return; await addDoc(collection(db,'rooms',currentRoomId,'messages'),{ name: currentUser ? (currentUser.displayName || currentUser.email) : 'Guest', text, ts: serverTimestamp() }); input.value=''; }

    // Recording helpers
    function getSupportedMimeType(){ const candidates = [ 'video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm', 'video/mp4' ]; for(const c of candidates){ try{ if(window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(c)) return c; }catch(e){} } return ''; }

    function startRecording(){
      if(!localScreenStream) return showStatus('error','No screen','Start sharing screen before recording');
      recordedBlobs = [];
      const mime = getSupportedMimeType();
      try{
        mediaRecorder = mime ? new MediaRecorder(localScreenStream, {mimeType:mime}) : new MediaRecorder(localScreenStream);
      }catch(e){ console.error('MediaRecorder error',e); return showStatus('error','Recording unavailable','MediaRecorder failed to start on this browser or with selected codecs.'); }

      mediaRecorder.ondataavailable = e => { if(e.data && e.data.size) recordedBlobs.push(e.data); };
      mediaRecorder.onstop = async () => {
        try{
          const blob = new Blob(recordedBlobs, {type: recordedBlobs[0]?.type || 'video/webm'});
          const fileName = `recordings/${currentRoomId}_${Date.now()}.webm`;
          const rRef = storageRef(storage, fileName);
          await uploadBytes(rRef, blob);
          const url = await getDownloadURL(rRef);
          await setDoc(doc(db,'rooms',currentRoomId,'archives','last'),{ url, uploadedAt: serverTimestamp() });
          showStatus('success','Recording saved','Recording uploaded successfully');
        }catch(e){ console.error('Upload failed',e); showStatus('error','Upload failed', e.message || 'Could not upload recording'); }
      };

      mediaRecorder.start(1000);
      const sBtn = document.getElementById('startRec'); const stopBtn = document.getElementById('stopRec'); if(sBtn) sBtn.style.display='none'; if(stopBtn) stopBtn.style.display='inline-block';
    }
    function stopRecording(){ if(mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop(); const sBtn = document.getElementById('startRec'); const stopBtn = document.getElementById('stopRec'); if(sBtn) sBtn.style.display='inline-block'; if(stopBtn) stopBtn.style.display='none'; }

    // Leave room
    async function leaveRoom(){ if(currentUser && currentRoomId){ try{ await deleteDoc(doc(db,'rooms',currentRoomId,'participants',currentUser.uid)); }catch(e){} }
      if(localScreenStream) localScreenStream.getTracks().forEach(t=>t.stop()); if(localMicStream) localMicStream.getTracks().forEach(t=>t.stop()); roomArea.innerHTML=''; currentRoomId=null; document.body.classList.remove('in-room'); heroSection.style.display='block';
    }

    // utils
    function generateId(len=6){ const s='ABCDEFGHJKMNPQRSTUVWXYZ23456789'; let r=''; for(let i=0;i<len;i++) r+=s[Math.floor(Math.random()*s.length)]; return r; }
    function parseRoomIdFromInput(v){ try{ const u=new URL(v); const p=new URLSearchParams(u.search); return p.get('room') || u.pathname.split('/').pop(); }catch(e){ return v; } }
    function escapeHtml(s){ return (s||'').toString().replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }

    // Auto-join if ?room= in url
    (function init(){ const params = new URLSearchParams(window.location.search); const rm = params.get('room'); if(rm){ currentRoomId = rm; document.body.classList.add('in-room'); heroSection.style.display='none'; renderClassroom(false); attachRoomListeners(rm); } })();
  </script>
</body>
</html>
